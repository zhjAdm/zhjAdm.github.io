{"meta":{"title":"醉氢峰のBlog","subtitle":"","description":"","author":"醉氢峰","url":"https://zhjadm.github.io","root":"/"},"pages":[{"title":"关于","date":"2021-04-29T14:27:04.000Z","updated":"2024-04-19T08:13:55.791Z","comments":true,"path":"about/index.html","permalink":"https://zhjadm.github.io/about/index.html","excerpt":"","text":"世事多舛，谁能窥测明日？不求繁华富贵，唯愿生活静如流水。"},{"title":"分类","date":"2014-12-22T04:39:04.000Z","updated":"2024-04-19T08:13:55.791Z","comments":true,"path":"categories/index.html","permalink":"https://zhjadm.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2014-12-22T04:39:04.000Z","updated":"2024-04-19T08:13:55.791Z","comments":true,"path":"tags/index.html","permalink":"https://zhjadm.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"面试记录二","slug":"面试记录二","date":"2024-04-10T06:34:07.000Z","updated":"2024-04-19T08:13:55.791Z","comments":true,"path":"archives/33156.html","link":"","permalink":"https://zhjadm.github.io/archives/33156.html","excerpt":"","text":"20240410 如何理解Spring、Srping Boot 和 Spring Cloud Spring 非入侵式：业务代码中不会出现 Spring 的API ；容器：提供容器，管理 bean 的生命周期以及对象之间的关系； IOC：控制反转，是一种编程思想将对象的创建控制权交给容器控制；AOP：面向切面编程，提供将公共逻辑代码抽离封装的能力，实现代码的解耦和重用 Spring Boot 相对于 Spring 而言简化的繁杂的配置工作，提高开发的效率。其设计理念是约定大于配置，所以提供了大量的starter 共给开发人员使用。同时内嵌了像 Tomcat，Jetty 等 sevelt 容器，简化了部署工作 Spring Cloud 是基于 Spring Boot 的一套微服务架构，依赖与很多套件实现服务间通讯，服务发现、配置管理等，本身自己不提供实际功能。 sql 怎么优化 添加索引，explain 命令可以查看 SQL 的执行计划，key：实际用到的索引和 rows：预计检查的行数。 不要使用 select * 用 union all 替代 union ：union会去重重排，排重的过程需要遍历、排序和比较，它更耗时，更消耗cpu资源 使用小表驱动大表：in 适用于左边大表，右边小表。 exists 适用于左边小表，右边大表。 尽量使用批量操作 需要单条数据时使用 limit in 中的值不要太多 分页查询 : 考虑使用自增ID或者时间 提高查询效率 用连接查询代替子查询： 子查询会创建临时表，查询结束后再删除增加额外的消耗 join 的表不易过多： left join 尽量左边要用小表，右边可以用大表。如果能用inner join的地方，尽量少用left join。 控制索引的数量： 更新和删除操作都会更新索引，如果索引过多，会消耗很多额外的性能。能够建联合索引，就别建单个索引，可以删除无用的单个索引。 使用where条件在分组前，就把多余的数据过滤掉 索引失效的原因 数据类型不匹配：如果查询条件中的数据类型和索引列的数据类型不一致，会导致索引失效。因为 MySql 会进行隐式类型转换，这会使索引无法被有效使用。 违反最左前缀原则：在使用联合索引时，查询条件必须遵循最左前缀原则，即从左到右依次使用联合索引中的列，不能跳过任何一列，否则索引会失效。 where 语句 索引列上进行了函数操作或运算：如果在查询条件中对索引列进行了函数操作或运算，如使用LOWER()函数等，会导致索引失效。 使用LIKE进行模糊查询且查询条件以通配符开头：当使用LIKE进行模糊查询，并且查询条件以通配符（%）开头时，索引会失效。因为数据库无法确定索引列的起始位置，所以无法利用索引进行快速查找。 索引列包含 NULL 值：如果索引列中包含 NULL 值，在查询条件中使用 IS NULL 或 IS NOT NULL 也会导致索引失效。因为MySQL 在建立索引时不会存储空值，所以无法通过索引来判断是否为空。 查询条件中使用 OR 关键字：如果查询条件中使用了 OR 关键字，并且 OR 两边的条件涉及到不同的索引列，那么也会导致索引失效。因为 MySQL 无法同时使用多个索引来进行查询优化，所以只能选择全表扫描。 in使用不当：in 在结果集 大于30%的时候索引失效 select * : 会导致回表查询所以影响查询效率；同时增加查询分析器解析成本和无用字段增加网络 耗，尤其是 text 类型的字段 最左匹配原则 联合索引(a,b,c)，会从左左侧开始匹配。假如没有a 则不会走索引，遇到范围查询会停止匹配。 事务失效的场景 没有被 public 修饰：在Spring源码中，如果目标方法不是public，则TransactionAttribute返回null，不支持事务 方法被 final 修饰：因为spring事务底层是用了aop，用了jdk的动态代理或者cglb的动态代理，会帮我们生成代理类，在代理类中实现事务功能 同一个类中调用 异常被捕获没有抛出 多线程异步调用 未指定回滚异常：解默认的回滚异常类型是运行时异常 Countdownlatch和CyclicBarrier ，多线程 mybatis plus 分页实现原理，拦截器 delete 影响索引吗 会，删除和更新会更新索引 redis 基本类型 String、list、set、zset（有序集合）、hash、stream、Bit arrays（位集合）、HyperLogLog（是用来做基数统计的算法。用于估计一个set中元素数量的概率性的数据结构。）、Geospatial Indexes（地理空间索引）、Streams（流信息） bean的生命周期 实例化：根据配置文件中 Bean 的定义，利用 Java Reflection 反射技术创建 Bean 的实例 属性注入：注入对象依赖的属性值（或对象） 处理各种 Aware 接口：Spring 会检测该 Bean 是否实现了 xxxAware 接口，通过 Aware 类型的接口，可以让 Spring 框架为当前 Bean 注入相对应的内容 ​ 如果 Bean 实现 BeanNameAware 接口，会调用实现的 setBeanName(string beanid)方法，注入bean 的名字；​ 如果 Bean 实现 BeanClassLoaderAware 接口，调用setBeanClassLoader()方法，注入 ClassLoader 对象的实例；​ 如果 Bean 实现 BeanFactoryAware 接口，会调用它实现的 setBeanFactory() 方法，注入的是 spring 工厂；​ 如果 Bean 实现 ApplicationContextAware 接口,会调用 setApplicationContext() 方法，注入 spring 上下文； 执行 BeanPostProcessor 前置处理：如果想对 Bean 进行一些自定义的前置处理，那么可以让Bean实现了BeanPostProcessor接口，将会在该阶段调用postprocessbeforeinitialization(Object obj,string s)方法 执行initializingBean初始化方法:如果Bean实现了initializingBean接口，执行afeterpropertiesset() 方法 ​ 执行init-method自定义初始化方法：如果Bean在spring配置文件中配置了init-method属性，则会自动调用其配置的初 始化方法 执行了Beanpostprocessor后置处理：如果这个Bean实现了Beanpostprocessor接口，将会调用postprocessafterinitialization(object obj,string s)方法，由于这个方法是在Bean初始化结束后调用 执行DisposableBean销毁Bean：当Bean不再需要时，会经历清理阶段，如果Bean实现了DisposableBean这个接口，会调用其实现的destory()方法执行销毁 ​ 执行destory-method自定义销毁方法：如果这个Bean的spring配置中配置了destory-method属性，会自动调用其配置 的自定义销毁方法。 如何理解面向对象 定义 就是将要完成的一件“大事”，分割出其中的一个一个“独立对象”，每个对象都有其自身的“特征信息”，和“行为动作/功能” 对象组成 方法和属性 特点 封装：将数据和操作封装在对象内部，只对外提供公共的访问方式，这样提高了安全性和可维护性 继承：继承允许一个类（子类）继承另一个类（父类）的属性和方法，这样可以复用父类的代码，提高开发效率 多态：一个类实例的相同方法在不同情形下有不同的表现形式，实现方式重载和重写 Java 反射机制 理解 在程序运行过程中，能够获取某一个类的属性和方法，并能够调用某一个对象的方法 redis使用场景 AOP具体使用 Lambda 表达式 123(parameters) -&gt; expression或(parameters) -&gt;&#123; statements; &#125; parameters：表示参数，没有小括号也不可省略，expression 和 { statements; } 表示方法体。 主要特性 简洁、可并行、方法引用（允许使用 :: 关键字来传递方法或者构造函数引用）、变量捕获（引用外部变量，该变量默然拥有 final 属性不可改变）、函数式编程支持（允许将函数当作参数传递给方法，或者将函数作为返回值","categories":[{"name":"面试","slug":"面试","permalink":"https://zhjadm.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhjadm.github.io/tags/Java/"},{"name":"面试","slug":"面试","permalink":"https://zhjadm.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"面试记录一","slug":"面试记录","date":"2024-04-07T12:56:53.000Z","updated":"2024-04-19T08:13:55.791Z","comments":true,"path":"archives/51622.html","link":"","permalink":"https://zhjadm.github.io/archives/51622.html","excerpt":"","text":"文会科技-20240407 接口幂等性 为什么会有接口幂等性的问题用户提交过程中出项网络波动，用户重复点击提交按钮，对第三方提供的接口超时往往会添加重试机制，使用MQ出现重复消费的问题 如何解决 用户点击提交后可以禁用提交按钮，实现起来简单但是前端控制往往不可靠 token机制，进入表单页获取提个token并存入redis中，提交后先尝试在redis中删除这个token，来判断是否重复提交 利用数据库的唯一索引实现，去重表 乐观锁，在数据库中有个版本号的字段，每次更新的时候对比版本号，如果不同则是被更新过 防止接口重复提交 利用Redis和aop去实现定义注解实现接口拦截，根据前端传递参数加用户ID生产唯一哈希值key 利用Redis的 setIfAbsent 实现，通过设置过期时间来控制重复提交的时间 前端通过禁用按钮实现简单但不可靠 使用ConcurrentHashMap和aop去实现利用线程安全版的HashMap，根据前端传递参数加用户ID生产唯一哈希值key存到map中。并利用定时任务是删除map中的key。 增加服务器性能消耗。 Linux下打开超大文件 查看文件的前多少行 head -10000 /var/lib/mysql/slowquery.log &gt; temp.log 上面命令的意思是：把slowquery.log文件前10000行的数据写入到temp.log文件中。 查看文件的后多少行 tail -10000 /var/lib/mysql/slowquery.log &gt; temp.log 上面命令的意思是：把slowquery.log文件后10000行的数据写入到temp.log文件中。 查看文件的几行到几行 sed -n ‘10,10000p’ /var/lib/mysql/slowquery.log &gt; temp.log 上面命令的意思是：把slowquery.log文件第10到10000行的数据写入到temp.log文件中。 aop 使用场景 日志记录 防止接口重复提交 数据权限控制 事务开启","categories":[{"name":"面试","slug":"面试","permalink":"https://zhjadm.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhjadm.github.io/tags/Java/"},{"name":"面试","slug":"面试","permalink":"https://zhjadm.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Spring 的控制反转(IoC)和面向切面(AOP)","slug":"Spring-的控制反转-IOC-和面向切面-AOP","date":"2024-03-16T06:38:28.000Z","updated":"2024-04-19T08:13:55.791Z","comments":true,"path":"archives/21589.html","link":"","permalink":"https://zhjadm.github.io/archives/21589.html","excerpt":"","text":"控制反转（IoC）是什么 控制反转本身是一种设计思想，非技术。是将对象交给容器控制，非传统通过在对象内部直接控制。传统的开发方式，我们通过new的方式创建一个对象，程序主动去创建并建立依赖。控制反转是将对象的创建交给容器，并让容器管理对象的整个生命周期，容器实现依赖的注入。相对与传统开发的主动创建对象建立依赖关系，通过容器创建管理对象，注入依赖所以叫作控制反转。 有什么作用 因为有原来在类内部自己创建对象，导致类与类之间存在很强的耦合关系。现在将控制权交给容器后，所以类与类之间变成了松耦合，有一利于代码功能的复用。 Ioc 和 DI IoC是设计思想，DI（依赖注入）是实现方式 IoC 配置方式 xml 配置方式 将bean对象的信息配置在xml文件中，Spring 加载配置文件根据配置的信息创建bean。但是配置方式繁琐，不利于维护。在 Spring boot 中该方式已经被抛弃。 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--suppress ALL --&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd &quot;&gt; &lt;!-- 使用无参构造器来创建对象。id属性：要求唯一 。class属性：要写类的完整的名称。 --&gt; &lt;bean id=&quot;a1&quot; class=&quot;first.Apple&quot;/&gt; &lt;bean id=&quot;date1&quot; class=&quot;java.util.Date&quot;/&gt; &lt;!-- 使用静态工厂方法来创建对象。 factory-method属性：用来指定静态方法名。注：Spring容器会调用该类的静态方法来创建一个对象。 --&gt; &lt;bean id=&quot;cal1&quot; class=&quot;java.util.Calendar&quot; factory-method=&quot;getInstance&quot;/&gt; &lt;!-- 使用实例工厂方法来创建对象： factory-bean属性：指定要调用的bean的id, factory-method属性：指定要调用的实例方法。 注：Spring容器会调用该bean的实例方法来创建对象。 在Spring框架里面，所谓的bean指的是由Spring容器管理的对象。--&gt; &lt;bean id=&quot;date2&quot; factory-bean=&quot;cal1&quot; factory-method=&quot;getTime&quot;/&gt;&lt;/beans&gt; Java 配置方式 通过Java的配置类实现bean的创建，本质的xml的方式相同不过是将配置信息转移到了Java配置类中。同样存在配置繁琐，存在大量配置的话不利于威化，可读变差。但是第三方资源还是需要通过这种或者xml的方式。 创建一个配置类 ，添加 @Configuration 注解声明为配置类。 方法上添加 @Bean 注解。方法内创建一个对象并返回。返回的该对象就会被IoC容器所管理。 123456789101112131415161718192021@Configurationpublic class BeansConfig &#123; /** * @return user dao */ @Bean(&quot;userDao&quot;) public UserDaoImpl userDao() &#123; return new UserDaoImpl(); &#125; /** * @return user service */ @Bean(&quot;userService&quot;) public UserServiceImpl userService() &#123; UserServiceImpl userService = new UserServiceImpl(); userService.setUserDao(userDao()); return userService; &#125;&#125; 注解方式 Spring 会扫描 @Component，@Controller，@Service，@Repository这四个注解的类，然后帮我们创建并管理，前提是需要先配置Spring的注解扫描器。使用起来方便快捷、便于维护，但第三方资源无法添加。 依赖注入方式 常用的注入方式主要有三种：构造方法注入（Construct注入），setter注入，基于注解的注入（接口注入） 面向切面编程 (AOP)是什么 和 IoC 同样是一种设计思想。理解为将不同业务模块相同的代进行抽离封装，从而降低模块之间的耦合度。Spring 中通过代理实现 AOP 有什么作用 可以通过AOP 实现模块之间的解耦，例如：系统中常见的日志记录功能，可以将各个模块中相同的代码抽取成独立的模块，利用 AOP 实现解耦。","categories":[{"name":"Java","slug":"Java","permalink":"https://zhjadm.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhjadm.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://zhjadm.github.io/tags/Spring/"}]},{"title":"Docker使用","slug":"Docker使用","date":"2023-05-11T02:24:05.000Z","updated":"2024-04-19T08:13:55.791Z","comments":true,"path":"archives/5123.html","link":"","permalink":"https://zhjadm.github.io/archives/5123.html","excerpt":"","text":"Dockerfile是什么Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。 关键指令 指令 说明 FROM 指定基础镜像 RUN 在构建过程中在镜像中执行命令。 CMD 指定容器创建时的默认命令。（可以被覆盖） ENTRYPOINT 设置容器创建时的主要命令。（不可被覆盖） EXPOSE 声明容器运行时监听的特定网络端口。 ENV 在容器内部设置环境变量。 ADD 将文件、目录或远程URL复制到镜像中。 COPY 将文件或目录复制到镜像中。 VOLUME 为容器创建挂载点或声明卷。 WORKDIR 设置后续指令的工作目录。 构建镜像1docker build -t runoob/ubuntu:v1 . -t : 镜像标签","categories":[{"name":"Docker","slug":"Docker","permalink":"https://zhjadm.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://zhjadm.github.io/tags/Docker/"}]},{"title":"图片旋转","slug":"图片旋转","date":"2023-03-27T08:30:23.000Z","updated":"2024-04-19T08:13:55.791Z","comments":true,"path":"archives/58969.html","link":"","permalink":"https://zhjadm.github.io/archives/58969.html","excerpt":"","text":"图片加载判断1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556addImg = function (url) &#123; let img = new Image(); img.src = url; let imgDivDom = $(&quot;#imgDiv&quot;); let height = imgDivDom.outerHeight(true) let width = imgDivDom.outerWidth(true) // 如果图片被缓存，则直接返回缓存数据 if (img.complete) &#123; imgDivDom.html(&#x27;&#x27;) imgDivDom.append(img) if (img.width &gt; img.height) &#123; imgDivDom.children(&#x27;img&#x27;).css(&#123; &quot;margin&quot;: &quot;0 auto&quot;, &quot;height&quot;: height + &quot;px&quot;, &quot;width&quot;: width + &quot;px&quot;, &quot;object-fit&quot;: &quot;contain&quot; &#125;) &#125; else &#123; imgDivDom.children(&#x27;img&#x27;).css(&#123; &quot;display&quot;: &quot;block&quot;, &quot;margin&quot;: &quot;0 auto&quot;, &quot;height&quot;: width + &quot;px&quot;, &quot;width&quot;: height + &quot;px&quot;, &quot;object-fit&quot;: &quot;contain&quot;, &quot;transform&quot;: &quot;rotate(90deg)&quot; &#125;) &#125; &#125; else &#123; // 完全加载完毕的事件 img.onload = function () &#123; imgDivDom.html(&#x27;&#x27;) imgDivDom.append(img) if (img.width &gt; img.height) &#123; imgDivDom.children(&#x27;img&#x27;).css(&#123; &quot;margin&quot;: &quot;0 auto&quot;, &quot;height&quot;: height + &quot;px&quot;, &quot;width&quot;: width + &quot;px&quot;, &quot;object-fit&quot;: &quot;contain&quot; &#125;) &#125; else &#123; imgDivDom.children(&#x27;img&#x27;).css(&#123; &quot;display&quot;: &quot;block&quot;, &quot;margin&quot;: &quot;0 auto&quot;, &quot;height&quot;: width + &quot;px&quot;, &quot;width&quot;: height + &quot;px&quot;, &quot;object-fit&quot;: &quot;contain&quot;, &quot;transform&quot;: &quot;rotate(90deg)&quot; &#125;) &#125; &#125; &#125; img.onerror = function ()&#123; imgDivDom.html(&#x27;&lt;div class=&quot;noImg&quot;&gt;暂无图片&lt;/div&gt;&#x27;) &#125; &#125; 父级元素样式 12display: flex;align-items: center;","categories":[{"name":"前端","slug":"前端","permalink":"https://zhjadm.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"css","slug":"css","permalink":"https://zhjadm.github.io/tags/css/"},{"name":"滚动条","slug":"滚动条","permalink":"https://zhjadm.github.io/tags/%E6%BB%9A%E5%8A%A8%E6%9D%A1/"}]},{"title":"Linx命令","slug":"Linx命令","date":"2023-03-09T15:15:55.000Z","updated":"2024-04-19T08:13:55.791Z","comments":true,"path":"archives/57987.html","link":"","permalink":"https://zhjadm.github.io/archives/57987.html","excerpt":"","text":"Linux命令后台运行1nohup 执行脚本 &gt; 输出日志.log 2&gt;&amp;1 &amp; 添加可执行权限1chmod +x 文件 查找指定进程1ps -aux | grep &quot;进程名&quot; 压缩1tar czvf 压缩文件名.tar.gz 被压缩文件夹 解压1tar zvxf 压缩文件名.tar.gz -C 目标文件夹 从服务器上下载文件1scp 用户名@服务器地址:要下载的文件路径 保存文件的文件夹路径 上传本地文件到服务器1scp 要上传的文件路径 用户名@服务器地址:服务器保存路径 从服务器下载整个目录1scp -r 用户名@服务器地址:要下载的服务器目录 保存下载的目录 上传目录到服务器1scp -r 要上传的目录 用户名@服务器地址:服务器的保存目录","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zhjadm.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zhjadm.github.io/tags/Linux/"}]},{"title":"初识Spring Security（二)","slug":"初识Spring-Security（二","date":"2022-07-02T13:26:10.000Z","updated":"2024-04-19T08:13:55.791Z","comments":true,"path":"archives/48147.html","link":"","permalink":"https://zhjadm.github.io/archives/48147.html","excerpt":"","text":"对于用户密码出于安全考虑需要加密存储，Spring Security提供了多种加密方式，官方推荐使用BCryptPasswordEncoder加密方式。其实BCryptPasswordEncoder的实现并非为一种加密算法，而是采用SHA-256 +随机盐+密钥对密码进行加密，SHA系列是Hash算法，其过程是不可逆的。用户注册时，使用SHA-256 +随机盐+密钥把用户输入的密码进行Hash处理，将得到的Hash值存入数据库。用户登陆时候采取同样的算法对密码进行Hash处理后于数据库中存储得密码Hash值进行比较。 SecurityUtils工具类Spring框架借助ThreadLocal来保存和传递用户登录信息。我们编写一个工具类方便的获取ThreadLocal中的用户信息名，以及用户密码的加密和比较工作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class SecurityUtils &#123; /** * 用户ID **/ public static String getUserId() &#123; try &#123; return getLoginUser().getUserId(); &#125; catch (Exception e) &#123; throw new BusinessException(ResultEnum.USER_NOT_EXIST); &#125; &#125; /** * 获取部门ID **/ public static String getOrganId() &#123; try &#123; return getLoginUser().getOrganId(); &#125; catch (Exception e) &#123; throw new BusinessException(ResultEnum.USER_NOT_ORGAN); &#125; &#125; /** * 获取用户账户 **/ public static String getUsername() &#123; try &#123; return getLoginUser().getUsername(); &#125; catch (Exception e) &#123; throw new BusinessException(ResultEnum.USER_NOT_ACCOUNT); &#125; &#125; /** * 获取用户 **/ public static SysUser getLoginUser() &#123; try &#123; return (SysUser) getAuthentication().getPrincipal(); &#125; catch (Exception e) &#123; throw new BusinessException(ResultEnum.USER_NOT_EXIST); &#125; &#125; /** * 获取Authentication */ public static Authentication getAuthentication() &#123; return SecurityContextHolder.getContext().getAuthentication(); &#125; /** * 生成BCryptPasswordEncoder密码 * * @param password 密码 * @return 加密字符串 */ public static String encryptPassword(String password) &#123; return &quot;&#123;bcrypt&#125;&quot; + new BCryptPasswordEncoder().encode(password); &#125; /** * 判断密码是否相同 * * @param rawPassword 真实密码 * @param encodedPassword 加密后字符 * @return 结果 */ public static boolean matchesPassword(String rawPassword, String encodedPassword) &#123; BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); return passwordEncoder.matches(rawPassword, encodedPassword); &#125; /** * 是否为超级管理员 * * @param userId 用户ID * @return 结果 */ public static boolean isAdmin(Long userId) &#123; return userId != null &amp;&amp; 1L == userId; &#125;&#125; 用户注册用户注册对用户填写的密码使用**SecurityUtils.encryptPassword()**进行加密处理即可 用户登陆流程1、登陆后台处理调用**authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(username, password))，该方法会去调用UserDetailsServiceImpl.loadUserByUsername()**。 123456789101112131415161718192021@Overridepublic LoginUser authLogin(UserLoginVo userLoginVo) &#123; String username = userLoginVo.getUsername(); String password = userLoginVo.getPassword(); // 用户验证 Authentication authentication = null; try &#123; // 该方法会去调用UserDetailsServiceImpl.loadUserByUsername authentication = authenticationManager .authenticate(new UsernamePasswordAuthenticationToken(username, password)); &#125; catch (Exception e) &#123; throw new BusinessException(500,e.getMessage()); &#125; LoginUser loginUser = (LoginUser) authentication.getPrincipal(); // recordLoginInfo(loginUser.getUserId()); // 生成 token String token = JwtTokenUtil.getRefreshToken(username, null); // 用户信息 loginUser.setToken(tokenHead + token); return loginUser;&#125; 2、自定义验证类UserDetailsService 实现Security框架UserDetailsService的接口。 123456789101112131415161718192021222324252627282930@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123;private static final Logger log = LoggerFactory.getLogger(UserDetailsServiceImpl.class);@Autowiredprivate SysUserService userService;/* @Autowiredprivate SysPermissionService permissionService;*/@Overridepublic UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; SysUser user = userService.getUserByUsername(username); if (user == null) &#123; log.info(&quot;登录用户：&#123;&#125; 不存在.&quot;, username); throw new BusinessException(&quot;登录用户：&quot; + username + &quot; 不存在&quot;); &#125; else if (UserStatus.DELETED.getCode() == user.getDelFlag()) &#123; log.info(&quot;登录用户：&#123;&#125; 已被删除.&quot;, username); throw new BusinessException(&quot;对不起，您的账号：&quot; + username + &quot; 已被删除&quot;); &#125; else if (UserStatus.DISABLE.getCode() == user.getUserState()) &#123; log.info(&quot;登录用户：&#123;&#125; 已被停用.&quot;, username); throw new BusinessException(&quot;对不起，您的账号：&quot; + username + &quot; 已停用&quot;); &#125; return createLoginUser(user);&#125;public UserDetails createLoginUser(SysUser user) &#123; return new LoginUser(user.getUserId(), user.getOrganId(), user);&#125;&#125; 3、我们自定义验证类UserDetailsService实现类中，需要实现的loadUserByUsername方法回返回一个UserDetails接口类，包含非安全相关的信息（如用户昵称，电话号码等），们只存储用户信息，这些信息随后被封装到Authentication对象中。所以我们可以创建其实现类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142public class LoginUser implements UserDetails &#123; private static final long serialVersionUID = 1L; /** * 用户ID */ private String userId; /** * 部门ID */ private String deptId; /** * 用户唯一标识 */ private String token; /** * 登录时间 */ private String loginTime; /** * 过期时间 */ private String expireTime; /** * 登录IP地址 */ private String ipaddr; /** * 登录地点 */ private String loginLocation; /** * 浏览器类型 */ private String browser; /** * 操作系统 */ private String os; /** * 权限列表 */ private Set&lt;String&gt; permissions; public LoginUser() &#123; &#125; public LoginUser(SysUser user, Set&lt;String&gt; permissions) &#123; this.user = user; this.permissions = permissions; &#125; public LoginUser(String userId, Long String, SysUser user, Set&lt;String&gt; permissions) &#123; this.userId = userId; this.deptId = deptId; this.user = user; this.permissions = permissions; &#125; public LoginUser(String userId, String deptId, SysUser user) &#123; this.userId = userId; this.deptId = deptId; this.user = user; &#125; /** * 用户信息 */ private SysUser user; public String getDeptId() &#123; return deptId; &#125; public void setDeptId(String deptId) &#123; this.deptId = deptId; &#125; public String getToken() &#123; return token; &#125; public void setToken(String token) &#123; this.token = token; &#125; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; return null; &#125; @Override @JsonIgnore public String getPassword() &#123; return user.getPassword(); &#125; @Override public String getUsername() &#123; return user.getUsername(); &#125; /** * 用户是否过期，没有过期就返回true */ @Override @JsonIgnore public boolean isAccountNonExpired() &#123; return true; &#125; /** * 用户是否被锁定，锁定返回true。 */ @Override @JsonIgnore public boolean isAccountNonLocked() &#123; return true; &#125; /** * 用户凭证是否可用，可用返回true */ @Override @JsonIgnore public boolean isCredentialsNonExpired() &#123; return true; &#125; /** * 用户是否启用了，启用了返回true */ @Override @JsonIgnore public boolean isEnabled() &#123; return true; &#125;&#125; 常见错误 There is no PasswordEncoder mapped for the id “null“ 问题的解决方法 错误 登陆报错There is no PasswordEncoder mapped for the id “null“ 原因 Spring Security5.x 对所配置的密码必须带上加密方式，如果没有带，就会解析不出来，所以抛错。 解决 储存密码是添加加密方式， 格式为{xxx}密码。 加密方式 原来security 4的密码格式 现在security 5的密码格式 bcrypt password {bcrypt}password ldap password {ldap}password MD4 password {MD4}password MD5 password {MD5}password noop password {noop}password pbkdf2 password {pbkdf2}password scrypt password {scrypt}password SHA-1 password {SHA-1}password SHA-256 password {SHA-256}password sha256 password {sha256}password","categories":[{"name":"Java","slug":"Java","permalink":"https://zhjadm.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhjadm.github.io/tags/Java/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"https://zhjadm.github.io/tags/Spring-Security/"}]},{"title":"初识Spring Security（一）","slug":"初识Spring-Security","date":"2022-07-02T09:15:00.000Z","updated":"2024-04-19T08:13:55.791Z","comments":true,"path":"archives/34298.html","link":"","permalink":"https://zhjadm.github.io/archives/34298.html","excerpt":"","text":"相关依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; Spring Securit配制文件SecurityConfig 处理访问无权限是返回结果 1234567891011121314@Componentpublic class RestfulAccessDeniedHandler implements AccessDeniedHandler &#123; @Override public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e) throws IOException, ServletException &#123; response.setCharacterEncoding(&quot;UTF-8&quot;); response.setContentType(&quot;application/json&quot;); //Jackson核心对象 ObjectMapper mapper = new ObjectMapper(); response.getWriter().println(mapper.writeValueAsString(Result.forbidden(&quot;所请求资源，没有权限访问！&quot;))); response.getWriter().flush(); &#125;&#125; 处理Token失效或未登录是返回结果 123456789101112@Componentpublic class RestAuthenticationEntryPoint implements AuthenticationEntryPoint &#123; @Override public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException &#123; response.setCharacterEncoding(&quot;UTF-8&quot;); response.setContentType(&quot;application/json&quot;); //Jackson核心对象 ObjectMapper mapper = new ObjectMapper(); response.getWriter().println(mapper.writeValueAsString(Result.unauthorized(&quot;未登录或者token失效！&quot;))); response.getWriter().flush(); &#125;&#125; 配制文件主要内容 SecurityConfig接管Spring Security的配置，必须要继承WebSecurityConfigurerAdapter重写configure方法。并且通常添加@EnableWebSecurity注解开启方法过滤注解 12345678910111213141516171819202122232425262728293031323334353637383940@Override protected void configure(HttpSecurity httpSecurity) throws Exception &#123; httpSecurity .csrf().disable() //关闭CSRF .sessionManagement()// 基于token，所以不需要session .sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 允许对于网站静态资源的无授权访问 .antMatchers(HttpMethod.GET, &quot;/&quot;, &quot;/*.html&quot;, &quot;/favicon.ico&quot;, &quot;/**/*.html&quot;, &quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/swagger-resources/**&quot;, &quot;/v2/api-docs/**&quot; ) .permitAll() // 对登录注册要允许匿名访问 .antMatchers(&quot;/system/user/login&quot;, &quot;/system/user/register&quot;) .permitAll() //跨域请求会先进行一次options请求 .antMatchers(HttpMethod.OPTIONS) .permitAll() //允许访问druid监控页面，由于CSRF跨站点请求伪造(Cross—Site Request Forgery)的原因，会进不去druid监控页面 .antMatchers(&quot;/druid/*&quot;) .permitAll() .anyRequest()// 除上面外的所有请求全部需要鉴权认证 .authenticated(); // 禁用缓存 httpSecurity.headers().cacheControl(); // 添加JWT filter httpSecurity.addFilterBefore(jwtAuthenticationTokenFilter(), UsernamePasswordAuthenticationFilter.class); // 添加自定义未授权和未登录结果返回 httpSecurity.exceptionHandling() .accessDeniedHandler(restfulAccessDeniedHandler) .authenticationEntryPoint(restAuthenticationEntryPoint); &#125; authenticationManager无法注入问题在项目起动过程时，报错AuthenticationManager无法注入问题。报错信息如下： 1Description: Field userService in com.zhjAdm.system.user.service.impl.UserDetailsServiceImpl required a bean of type ‘org.springframework.security.authentication.AuthenticationManager’ that could not be found. The injection point has the following annotations: - @org.springframework.beans.factory.annotation.Autowired(required=true) Action: Consider defining a bean of type ‘org.springframework.security.authentication.AuthenticationManager’ in your configuration. 1234567解决方案，在配制文件中添加：```java @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean(); &#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhjadm.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhjadm.github.io/tags/Java/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"https://zhjadm.github.io/tags/Spring-Security/"}]},{"title":"Java导出之Excel","slug":"Java导出之Excel","date":"2021-10-22T14:33:06.000Z","updated":"2024-04-19T08:13:55.791Z","comments":true,"path":"archives/55014.html","link":"","permalink":"https://zhjadm.github.io/archives/55014.html","excerpt":"","text":"Java通过模板导出ExcelPOIApache POI是Apache软件基金会的开放源码库，POI提供API给Java程序对Microsoft Office格式文件读和写的功能。 HSSF和XSSF针对不同版本的Excel，在POI中提供了HSSF和XSSF不同的包。HSSF － 提供读写Microsoft Excel XLS格式档案的功能。XSSF － 提供读写Microsoft Excel OOXML XLSX格式档案的功能。 相关依赖123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;4.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;4.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml-schemas&lt;/artifactId&gt; &lt;version&gt;4.1.2&lt;/version&gt;&lt;/dependency&gt; 工具类writeExcel()f方法根据模板生成Excel，writeToResponse()方法将生成的Excel写入response中返回前端下载。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270public class ExcelUtils &#123; private static final String REG = &quot;\\\\&#123;([a-zA-Z_1-9]+)\\\\&#125;&quot;;// 匹配&quot;&#123;exp&#125;&quot; private static final String REG_LIST = &quot;\\\\&#123;\\\\.([a-zA-Z_1-9]+)\\\\&#125;&quot;;// 匹配&quot;&#123;.exp&#125;&quot; private static final Pattern PATTERN = Pattern.compile(REG); private static final Pattern PATTERN_LIST = Pattern.compile(REG_LIST); private ExcelUtils() &#123; &#125; /** * 根据模板生成Excel文件 * * @param templateFilePath 模版文件路径 * @param context 表头或表尾数据集合 * @param dataList 列表 * @return */ public static byte[] writeExcel(String templateFilePath, Map&lt;String, Object&gt; context, List&lt;?&gt; dataList) &#123; // File templateFile = null; ClassPathResource classPathResource = new ClassPathResource(templateFilePath); InputStream inputStream = null; try &#123; inputStream = classPathResource.getInputStream(); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(&quot;获取模板失败!&quot;, e); &#125; try (HSSFWorkbook workbook = new HSSFWorkbook(inputStream)) &#123; Sheet sheet = workbook.getSheetAt(0);// 获取配置文件sheet 页 int listStartRowNum = -1; for (int i = sheet.getFirstRowNum(); i &lt;= sheet.getLastRowNum(); i++) &#123; Row row = sheet.getRow(i); if (row != null) &#123; for (int j = 0; j &lt; row.getLastCellNum(); j++) &#123; Cell cell = row.getCell(j); if (cell != null &amp;&amp; cell.getCellType() == CellType.STRING) &#123; String cellValue = cell.getStringCellValue(); // 获取到列表数据所在行 if (listStartRowNum == -1 &amp;&amp; cellValue.matches(REG_LIST)) &#123; listStartRowNum = i; &#125; Object newValue = cellValue; Matcher matcher = PATTERN.matcher(cellValue); while (matcher.find()) &#123; String replaceExp = matcher.group();// 匹配到的表达式 String key = matcher.group(1);// 获取key Object replaceValue = context.get(key); if (replaceValue == null) &#123; replaceValue = &quot;&quot;; &#125; if (replaceExp.equals(cellValue)) &#123;// 单元格是一个表达式 newValue = replaceValue; &#125; else &#123;// 以字符串替换 newValue = ((String) newValue).replace(replaceExp, replaceValue.toString()); &#125; &#125; setCellValue(cell, newValue); &#125; &#125; &#125; &#125; if (-1 != listStartRowNum) &#123;// 如果不为 -1 说明有需要循环的列表表达式 Row listStartRow = sheet.getRow(listStartRowNum); if (CollectionUtils.isEmpty(dataList)) &#123;// 列表数据为空，清空列表表达式行 for (int i = 0; i &lt; listStartRow.getLastCellNum(); i++) &#123; Cell cell = listStartRow.getCell(i); if (cell != null) &#123; cell.setCellValue(&quot;&quot;); &#125; &#125; &#125; else &#123; int lastCellNum = listStartRow.getLastCellNum(); if (listStartRowNum + 1 &lt;= sheet.getLastRowNum()) &#123; sheet.shiftRows(listStartRowNum + 1, sheet.getLastRowNum(), dataList.size(), true, false);// 列表数据行后面行下移，留出数据填充区域 &#125; for (int i = 0; i &lt; dataList.size(); i++) &#123;// 循环列表数据 生成行 JSONObject jsonObj = (JSONObject) JSON.toJSON(dataList.get(i)); //Map&lt;String, Object&gt; map = dataList.get(i);// 一行数据 int newRowNum = listStartRowNum + i + 1;// 保留表达式行 Row newRow = sheet.createRow(newRowNum);// 创建新行 for (int j = 0; j &lt; lastCellNum; j++) &#123;// 循环遍历单元格 Cell cell = listStartRow.getCell(j);// 列表数据行 // 填充数据 if (cell != null) &#123; Cell newCell = newRow.createCell(j); newCell.setCellStyle(cell.getCellStyle());// 设置单元格格式 if (cell.getCellType() == CellType.STRING &amp;&amp; cell.getStringCellValue().matches(REG_LIST)) &#123;// 单元格是一个表达式 String cellExp = cell.getStringCellValue(); Matcher matcher = PATTERN_LIST.matcher(cellExp); matcher.find(); String key = matcher.group(1);// 获取key Object newValue = jsonObj.get(key); if (newValue == null) &#123; newValue = &quot;&quot;; &#125; setCellValue(newCell, newValue); &#125; else &#123;// 不是表达式复制单元格数据 CellType cellType = cell.getCellType(); if (cellType == CellType.NUMERIC) &#123; newCell.setCellValue(cell.getNumericCellValue()); &#125; else if (cellType == CellType.BOOLEAN) &#123; newCell.setCellValue(cell.getBooleanCellValue()); &#125; else if (cellType == CellType.STRING) &#123; newCell.setCellValue(cell.getStringCellValue()); &#125; else if (cellType == CellType.FORMULA) &#123; // 处理公式，待实现 &#125; else &#123; newCell.setCellValue(cell.getStringCellValue()); &#125; &#125; &#125; &#125; &#125; sheet.removeRow(listStartRow);// 删除list表达式行 sheet.shiftRows(listStartRowNum + 1, sheet.getLastRowNum(), -1, true, false);// 数据区域上移一行，覆盖表达式行 // 合并单元格处理 for (int i = 0; i &lt; lastCellNum; i++) &#123; CellRangeAddress mergedRangeAddress = getMergedRangeAddress(sheet, listStartRowNum, i); if (mergedRangeAddress != null) &#123;// 合并的单元格 i = mergedRangeAddress.getLastColumn(); for (int j = 1; j &lt; dataList.size(); j++) &#123; int newRowNum = listStartRowNum + j; sheet.addMergedRegionUnsafe(new CellRangeAddress(newRowNum, newRowNum, mergedRangeAddress.getFirstColumn(), mergedRangeAddress.getLastColumn())); &#125; &#125; &#125; &#125; &#125; // 公式生效 sheet.setForceFormulaRecalculation(true); sheet.getPrintSetup().setPaperSize(PrintSetup.A4_PAPERSIZE); sheet.getPrintSetup().setLandscape(true); // FitHeight=1, 将所有行都缩放显示在一页上（设置1表示一页显示完，如果设置2表示分2页显示完） // FitWidth=1, 将所有列都缩放显示在一页上 // 两个都等于1时，如果行数太多则会挤压列，一般来说只设置一个FitWidth=1，让行数自动换页 // 要使这两个参数有效，则需要设置FitToPage=true sheet.setFitToPage(true); sheet.getPrintSetup().setFitWidth((short) 1);// sheet.getPrintSetup().setFitHeight((short)1); // 是否显示自动换页符 sheet.setAutobreaks(true); ByteArrayOutputStream out = new ByteArrayOutputStream(); workbook.write(out); return out.toByteArray(); &#125; catch (Exception e) &#123; throw new ExcelException(&quot;生成excel失败!&quot;, e); &#125; &#125; private static void setCellValue(Cell cell, Object value) &#123; if (value instanceof Number) &#123;// 如果是数字类型的设置为数值 cell.setCellValue(Double.parseDouble(value.toString())); &#125; else if (value instanceof Date) &#123;// 如果为时间类型的设置为时间 cell.setCellValue((Date) value); &#125; else if (value instanceof String) &#123; cell.setCellValue((String) value); &#125; else if (value instanceof Boolean) &#123; cell.setCellValue((Boolean) value); &#125; else &#123; cell.setCellValue(value.toString()); &#125; &#125; /** * 获取指定行/列的合并单元格区域 * * @param sheet * @param row * @param column * @return CellRangeAddress 不是合并单元格返回null */ private static CellRangeAddress getMergedRangeAddress(Sheet sheet, int row, int column) &#123; List&lt;CellRangeAddress&gt; mergedRegions = sheet.getMergedRegions(); for (CellRangeAddress cellAddresses : mergedRegions) &#123; if (row &gt;= cellAddresses.getFirstRow() &amp;&amp; row &lt;= cellAddresses.getLastRow() &amp;&amp; column &gt;= cellAddresses.getFirstColumn() &amp;&amp; column &lt;= cellAddresses.getLastColumn()) &#123; return cellAddresses; &#125; &#125; return null; &#125; static class ExcelException extends RuntimeException &#123; private static final long serialVersionUID = -2772261598232964002L; public ExcelException(String msg, Throwable e) &#123; super(msg, e); &#125; public ExcelException(String msg) &#123; super(msg); &#125; &#125; /** * Description: 1、通过浏览器以流的形式输出,为了处理中文表名问题. * * @param bytes 文件对象 * @param request * @param response * @param fileName 文件名 */ public static void writeToResponse(byte[] bytes, HttpServletRequest request, HttpServletResponse response, String fileName) &#123; try &#123; String userAgent = request.getHeader(&quot;User-Agent&quot;); // 解决中文乱码问题 String fileName1 = fileName + &quot;.xls&quot;; String newFilename = URLEncoder.encode(fileName1, &quot;UTF8&quot;); // 如果没有userAgent，则默认使用IE的方式进行编码，因为毕竟IE还是占多数的 String rtn = &quot;filename=\\&quot;&quot; + newFilename + &quot;\\&quot;&quot;; if (userAgent != null) &#123; userAgent = userAgent.toLowerCase(); // IE浏览器，只能采用URLEncoder编码 if (userAgent.indexOf(&quot;IE&quot;) != -1) &#123; rtn = &quot;filename=\\&quot;&quot; + newFilename + &quot;\\&quot;&quot;; &#125; // Opera浏览器只能采用filename* else if (userAgent.indexOf(&quot;OPERA&quot;) != -1) &#123; rtn = &quot;filename*=UTF-8&#x27;&#x27;&quot; + newFilename; &#125; // Safari浏览器，只能采用ISO编码的中文输出 else if (userAgent.indexOf(&quot;SAFARI&quot;) != -1) &#123; rtn = &quot;filename=\\&quot;&quot; + new String(fileName1.getBytes(&quot;UTF-8&quot;), &quot;ISO8859-1&quot;) + &quot;\\&quot;&quot;; &#125; // FireFox浏览器，可以使用MimeUtility或filename*或ISO编码的中文输出 else if (userAgent.indexOf(&quot;FIREFOX&quot;) != -1) &#123; rtn = &quot;filename*=UTF-8&#x27;&#x27;&quot; + newFilename; &#125; &#125; String headStr = &quot;attachment; &quot; + rtn; response.setContentType(&quot;multipart/form-data&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); response.setHeader(&quot;Content-Disposition&quot;, headStr); // 响应到客户端 OutputStream outputStream = response.getOutputStream(); outputStream.write(bytes); outputStream.flush(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 模板制作制作模板时注意表格内数据与表头表尾数据变量命名区别，表格内数据变量前添加【.】用于标识表格数据。","categories":[{"name":"Java","slug":"Java","permalink":"https://zhjadm.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhjadm.github.io/tags/Java/"},{"name":"POI","slug":"POI","permalink":"https://zhjadm.github.io/tags/POI/"}]},{"title":"Java中的异常（Error与Exception）","slug":"Java中的异常（Error与Exception）","date":"2021-06-20T06:59:06.000Z","updated":"2024-04-19T08:13:55.791Z","comments":true,"path":"archives/45192.html","link":"","permalink":"https://zhjadm.github.io/archives/45192.html","excerpt":"","text":"简介程序在运行时，发生不被期望的事件，它影响程序的正常执行，这被称为异常。Java中拥有自己的异常处理机制，当异常发生时能够按照代码预设的处理逻辑，来减少异常对后续程序运行影响，尽可能保证程序正常的运行。这些异常有的是因为用户错误引起，有的是程序错误引起的，还有其它一些是因为物理错误引起的。 Java中的异常体系为万物皆对象的Java中，异常同样也是作为一个对象处理。Throwable 是 Java 语言中所有错误（Error）和异常（Exception）的超类。在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。 1.Error无法被程序所处理的错误。例如，Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。 2.Exception程序本身可以处理的异常，可以通过catch捕获。 Exception又分为受检查异常(必须处理) 和不受检查异常(可以不处理)。 受检查异常Java代码在编译的过程中，如果没有被try/catch包围处理的话，就不会被编译通过。除了RuntimeException及其子类以外，其他的Exception类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、ClassNotFoundException 、SQLException等等。 不受检查异常Java中即使我们不做处理同样可以编译通过。RuntimeExceptiongit及其子类都统称为非受检查异常，例如：NullPointerException、NumberFormatException（字符串转换为数字）、ArrayIndexOutOfBoundsException（数组越界）、ClassCastException（类型转换错误）、ArithmeticException（算术错误）等等。 3.try-catch-finally1 ```","categories":[{"name":"Java","slug":"Java","permalink":"https://zhjadm.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhjadm.github.io/tags/Java/"},{"name":"异常","slug":"异常","permalink":"https://zhjadm.github.io/tags/%E5%BC%82%E5%B8%B8/"}]},{"title":"滚动条探索之美化","slug":"滚动条探索之美化","date":"2021-05-07T13:28:37.000Z","updated":"2024-04-19T08:13:55.791Z","comments":true,"path":"archives/8599.html","link":"","permalink":"https://zhjadm.github.io/archives/8599.html","excerpt":"","text":"webkit下css实现样式修改基于webkit内核的浏览器可通过-webkit-scrollbar伪元素实现对滚动条样式的控制。 1234567::-webkit-scrollbar — 整个滚动条.::-webkit-scrollbar-button — 滚动条上的按钮 (上下箭头).::-webkit-scrollbar-thumb — 滚动条上的滚动滑块.::-webkit-scrollbar-track — 滚动条轨道.::-webkit-scrollbar-track-piece — 滚动条没有滑块的轨道部分.::-webkit-scrollbar-corner — 当同时有垂直滚动条和水平滚动条时交汇的部分.::-webkit-resizer — 两个滚动条的交汇处上用于通过拖动调整元素大小的小控件 例子123456789101112131415::-webkit-scrollbar&#123;/*滚动条整体*/ width: 45px;&#125;::-webkit-scrollbar-thumb&#123;/*滚动条里面的小方块*/ background: #666666; border-radius: 45px;&#125;::-webkit-scrollbar-track&#123;/*滚动条轨道的样式*/ background: #ccc; border-radius: 5px;&#125;::-webkit-scrollbar-track-piece&#123;/*滚动条没有滑块的轨道样式*/ background: rgb(1, 117, 133); border-radius: 45px;&#125; ::-webkit-scrollbar 为一切的基础，并且所有的伪元素后面可通过添加:vertical和:horizontal两个伪类来是定所调整的为纵向还是横向滚动条。 IE下css实现样式修改IE浏览器仅支持修改颜色，无法对滚动条的形状大小进行修改。 12345678scrollbar-arrow-color: color; /*三角箭头的颜色*/scrollbar-face-color: color; /*立体滚动条的颜色（包括箭头部分的背景色）*/scrollbar-3dlight-color: color; /*立体滚动条亮边的颜色*/scrollbar-highlight-color: color; /*滚动条的高亮颜色（左阴影？）*/scrollbar-shadow-color: color; /*立体滚动条阴影的颜色*/scrollbar-darkshadow-color: color; /*立体滚动条外阴影的颜色*/scrollbar-track-color: color; /*立体滚动条背景颜色*/scrollbar-base-color:color; /*滚动条的基色*/ NiceScroll插件实现滚动条美化介绍基于jQuery实现的滚动条插件，无需额外的css启用只需一行代码，灵活方便可完全自定义滚动条的样式。几乎兼容全部的浏览器，同时支持触摸事件。 用法引入jQuery和nicescroll 123&lt;div class=&quot;boxscroll&quot;&gt; &lt;div class=&quot;contentscroll&quot;&gt;&lt;/div&gt;&lt;/div&gt; 只需下面简单一行代码便可实现滚动条的开启,nicescroll不依赖原本浏览器样式。 1$(&quot;.boxscroll&quot;).niceScroll(); 效果如下： 修改样式也同样的方便，niceScroll()传入想修改的参数即可。 1$(&quot;.boxscroll&quot;).niceScroll(&#123;cursorcolor:&quot;#F00&quot;,cursoropacitymax:0.7&#125;); 配置参数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152cursorcolor: &quot;#424242&quot;, // 滚动条光标的颜色 change cursor color in hexcursoropacitymin: 0, // 滚动条在不激活状态下的透明度，默认是0 change opacity when cursor is inactive (scrollabar &quot;hidden&quot; state), range from 1 to 0cursoropacitymax: 1, //滚动条在激活状态下的透明度，默认是1 change opacity when cursor is active (scrollabar &quot;visible&quot; state), range from 1 to 0cursorwidth: &quot;5px&quot;, // 滚动条宽度 cursor width in pixel (you can also write &quot;5px&quot;)cursorborder: &quot;1px solid #fff&quot;, //用css定义滚动条的边框 css definition for cursor bordercursorborderradius: &quot;5px&quot;, //滚动条的圆角半径 border radius in pixel for cursorzindex: &quot;auto&quot; | &lt;number&gt;, //改变滚动条div的z-index的值 change z-index for scrollbar divscrollspeed: 60, // 滚动速度mousescrollstep: 40, //使用鼠标轮滚的时候的滚动速度 scrolling speed with mouse wheel (pixel)touchbehavior: false, //在桌面电脑上启用光标拖动，就像触摸设备那样 enable cursor-drag scrolling like touch devices in desktop computerhwacceleration: true, //如果设备支持，则启用硬件加速 use hardware accelerated scroll when supportedboxzoom: false, //给盒子的内容启用放大缩小功能 enable zoom for box contentdblclickzoom: true, //双击放大，在boxzoom=true的情况下 (only when boxzoom=true) zoom activated when double click on boxgesturezoom: true, //手势放大缩小，在boxzoom=true的情况下 (only when boxzoom=true and with touch devices) zoom activated when pinch out/in on boxgrabcursorenabled: true //这个可以禁用&quot;grab&quot;鼠标光标 (only when touchbehavior=true) display &quot;grab&quot; iconautohidemode: true, //设置在什么情况下隐藏scrollbar。 how hide the scrollbar works, possible values: true | // 在不滚动情况下隐藏。 hide when no scrolling &quot;cursor&quot; | //只隐藏光标 only cursor hidden false | //始终不隐藏 do not hide, &quot;leave&quot; | //只在鼠标离开内容区是隐藏 hide only if pointer leaves content &quot;hidden&quot; | //使用隐藏 hide always &quot;scroll&quot;, //只在滚动的情况下显示，在不滚动的时候隐藏 show only on scroll background: &quot;&quot;, //设置背景颜色 change css for rail backgroundiframeautoresize: true, //在iframe的load事件中自动设置大小 autoresize iframe on load eventcursorminheight: 32, //设置最小的光标高度 set the minimum cursor height (pixel)preservenativescrolling: true, //这个设置通过事件冒泡的方式使你能够滚动原生的滚动条。 you can scroll native scrollable areas with mouse, bubbling mouse wheel eventrailoffset: false, //设置轨道的上或者左的偏移 you can add offset top/left for rail positionbouncescroll: false, //启用向手机上面的那种滚动回弹 (only hw accell) enable scroll bouncing at the end of content as mobile-like spacebarenabled: true, // enable page down scrolling when space bar has pressedrailpadding: &#123; top: 0, right: 0, left: 0, bottom: 0 &#125;, //设置轨道的内间距 set padding for rail bardisableoutline: true, //在chrome浏览器上选择一个div使用nicescroll时禁用outline， for chrome browser, disable outline (orange highlight) when selecting a div with nicescrollhorizrailenabled: true, //设置是否处理水平滚动 nicescroll can manage horizontal scrollrailalign: right, //垂直对齐方式 alignment of vertical railrailvalign: bottom, //水平对齐方式 alignment of horizontal railenabletranslate3d: true, //设置nicescroll是否使用css translate去滚动内容 nicescroll can use css translate to scroll contentenablemousewheel: true, //设置是否响应鼠标滚动事件 nicescroll can manage mouse wheel eventsenablekeyboard: true, //设置是否响应键盘事件 nicescroll can manage keyboard eventssmoothscroll: true, //使用平滑滚动 scroll with ease movementsensitiverail: true, //在轨道上点击时是否滚动 click on rail make a scrollenablemouselockapi: true, // can use mouse caption lock API (same issue on object dragging)cursorfixedheight: false, //给光标设置固定的高度 set fixed height for cursor in pixelhidecursordelay: 400, //设置隐藏光标的延迟时间，单位是毫秒 set the delay in microseconds to fading out scrollbarsdirectionlockdeadzone: 6, // dead zone in pixels for direction lock activationnativeparentscrolling: true, //检测内容的底部和父节点是否允许滚动，像原生滚动条的实现方式 detect bottom of content and let parent to scroll, as native scroll doesenablescrollonselection: true, //在选择文字的时候自动滚动内容 enable auto-scrolling of content when selection textcursordragspeed: 0.3, //当拖动光标时候的速度 speed of selection when dragged with cursorrtlmode: &quot;auto&quot;, //设置水平滚动div的起始边是左还是右 horizontal div scrolling starts at left sidecursordragontouch: false, //设置在触摸模式下，是否可以拖动光标就可以滚动 drag cursor in touch / touchbehavior mode alsooneaxismousemode: &quot;auto&quot;, //设置鼠标滚轮在只有水平模式的情况下是否可用 it permits horizontal scrolling with mousewheel on horizontal only content, if false (vertical-only) mousewheel don&#x27;t scroll horizontally, if value is auto detects two-axis mousescriptpath: &quot;&quot; //设置box模式下图标的路径，设成&quot;&quot;表示和script是同一个路径 define custom path for boxmode icons (&quot;&quot; =&gt; same script path)preventmultitouchscrolling: true //防止在多点触摸情况下滚动 prevent scrolling on multitouch eventsdisablemutationobserver: false //稳定滚动条 force MutationObserver disabled","categories":[{"name":"前端","slug":"前端","permalink":"https://zhjadm.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"css","slug":"css","permalink":"https://zhjadm.github.io/tags/css/"},{"name":"滚动条","slug":"滚动条","permalink":"https://zhjadm.github.io/tags/%E6%BB%9A%E5%8A%A8%E6%9D%A1/"}]}],"categories":[{"name":"面试","slug":"面试","permalink":"https://zhjadm.github.io/categories/%E9%9D%A2%E8%AF%95/"},{"name":"Java","slug":"Java","permalink":"https://zhjadm.github.io/categories/Java/"},{"name":"Docker","slug":"Docker","permalink":"https://zhjadm.github.io/categories/Docker/"},{"name":"前端","slug":"前端","permalink":"https://zhjadm.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Linux","slug":"Linux","permalink":"https://zhjadm.github.io/categories/Linux/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhjadm.github.io/tags/Java/"},{"name":"面试","slug":"面试","permalink":"https://zhjadm.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Spring","slug":"Spring","permalink":"https://zhjadm.github.io/tags/Spring/"},{"name":"Docker","slug":"Docker","permalink":"https://zhjadm.github.io/tags/Docker/"},{"name":"css","slug":"css","permalink":"https://zhjadm.github.io/tags/css/"},{"name":"滚动条","slug":"滚动条","permalink":"https://zhjadm.github.io/tags/%E6%BB%9A%E5%8A%A8%E6%9D%A1/"},{"name":"Linux","slug":"Linux","permalink":"https://zhjadm.github.io/tags/Linux/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"https://zhjadm.github.io/tags/Spring-Security/"},{"name":"POI","slug":"POI","permalink":"https://zhjadm.github.io/tags/POI/"},{"name":"异常","slug":"异常","permalink":"https://zhjadm.github.io/tags/%E5%BC%82%E5%B8%B8/"}]}